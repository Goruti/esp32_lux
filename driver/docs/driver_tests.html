

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Driver Tests &mdash; SmartThings Edge Device Drivers  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="SmartThings Edge Device Drivers  documentation" href="index.html"/>
        <link rel="up" title="&lt;no title&gt;" href="reference/index.html"/>
        <link rel="next" title="Datastore" href="datastore.html"/>
        <link rel="prev" title="Dispatchers" href="dispatchers.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> SmartThings Edge Device Drivers
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Guides:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="guides/getting-started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="guides/first-driver.html">Writing your first Lua driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="guides/package.html">Package Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="guides/lan.html">LAN Edge Device Driver Development Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="guides/rpc-client.html">Writing an RPC Client Driver</a></li>
</ul>
<p class="caption"><span class="caption-text">References:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="lua_environment.html">Lua Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="log.html">Logging Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">Utils Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="buf.html">Buffer Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="zigbee/zigbee.html">Zigbee Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="zwave/zwave.html">Z-Wave Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="drivers.html">Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="capabilities.html">Capabilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="device.html">Devices</a></li>
<li class="toctree-l1"><a class="reference internal" href="dispatchers.html">Dispatchers</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Driver Tests</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#setting-up-a-driver-test">Setting up a driver test</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#test-devices">Test devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#environment-preparation">Environment Preparation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#test-init">test_init</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#message-driver-tests">Message Driver Tests</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#opts">opts</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#inner-block-ordering">inner_block_ordering</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id2">test_init</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#coroutine-tests">Coroutine Tests</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">opts</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id4">test_init</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="datastore.html">Datastore</a></li>
<li class="toctree-l1"><a class="reference internal" href="socket.html">Socket Library</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">SmartThings Edge Device Drivers</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="reference/index.html">&lt;no title&gt;</a> &raquo;</li>
        
      <li>Driver Tests</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/driver_tests.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="driver-tests">
<h1>Driver Tests<a class="headerlink" href="#driver-tests" title="Permalink to this headline">¶</a></h1>
<p>In order to facilitate making changes to drivers while feeling confident that things don’t break an integration test
framework for drivers is provided.  Because of the nature of the drivers execution environment, the simplest way to test
is through checking that a given input message(s) produces the expected output message(s).  There are two
ways these can be set up.  A “message” driver test is one where the test can be boiled down to a simple series of
“receive” messages (external source -&gt; driver) that produce “send” messages (driver -&gt; external source).  These can be
then listed in the expected sequence as a part of a “message_test” and it will verify that the sequence of messages is
produced.  Typically this type of test will be sufficient for most cases that don’t involve timers, or validating values
stored to the drivers datastore (i.e. persistent storage). If you do need to check those additional things, or want to
include more complex logic in how you determine what messages are expected, it can be done using a <cite>coroutine_test</cite>
which allows you define a function that will be run as a coroutine that will have a chance to execute whenever your
driver would normally make a call to <cite>select</cite> to wait for a “receive” message.  You can then intersperse calls to
<cite>integration_test.wait_for_events()</cite> to return control to the driver to let it process “receive” messages and generate
expected “send” messages before it naturally returns to the <cite>select</cite> call to wait for more input, where your test
function will resume execution for its next block.  As a note, a “message” driver test is converted to a coroutine test
for actual execution, it is just provided as a potentially simpler interface if it is preferred.</p>
<div class="section" id="setting-up-a-driver-test">
<h2>Setting up a driver test<a class="headerlink" href="#setting-up-a-driver-test" title="Permalink to this headline">¶</a></h2>
<p>The first thing that needs to be done is to require the unit test framework.  This will provide some global functions
that can be used for running the tests as well as mock out and override the input/output message streams that are
normally used for driver communication.  This can be done simply by requiring the test file</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Import the integration test module to override input/output streams</span>
<span class="nb">require</span> <span class="s2">&quot;integration_test&quot;</span>
</pre></div>
</div>
<div class="section" id="test-devices">
<h3>Test devices<a class="headerlink" href="#test-devices" title="Permalink to this headline">¶</a></h3>
<p>The next thing that will be necessary for most tests is to define the devices that will be running in your driver.
Unless you have a lot of unique behavior, the primary thing you will need to define is the devices “profile” which
consists of the components that the device has as well as the capabilities that each of those components support.  The
simplest option is to use one of the profiles you already have defined in your package.  This can be done using the
<cite>test_utils.get_profile_definition(“profile-file-name.yml”)</cite> call available in <cite>integration_tests.utils</cite>. It
is also common to use a protocol specific helper for creating these devices such as
<code class="docutils literal notranslate"><span class="pre">integration_test.build_test_zigbee_device(device_template)</span></code>.  The final thing you will need to do with these devices
is to add them to your driver under test.  This can be done simply using <code class="docutils literal notranslate"><span class="pre">integration_test.add_test_device(device)</span></code>.
However, because these devices will be reset in between each test, you will want to use a <code class="docutils literal notranslate"><span class="pre">test_init</span></code> function (see
next section).  Following is an example that will set up a test Zigbee device for a single test</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="kd">local</span> <span class="n">test</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">&quot;integration_test&quot;</span>
<span class="kd">local</span> <span class="n">t_utils</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">&quot;integration_test.utils&quot;</span>

<span class="kd">local</span> <span class="n">mock_simple_device</span> <span class="o">=</span> <span class="n">test</span><span class="p">.</span><span class="n">mock_device</span><span class="p">.</span><span class="n">build_test_zigbee_device</span><span class="p">(</span> <span class="p">{</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">t_utils</span><span class="p">.</span><span class="n">get_profile_definition</span><span class="p">(</span><span class="s2">&quot;test-profile.yml&quot;</span><span class="p">)</span> <span class="p">}</span> <span class="p">)</span>
<span class="n">test</span><span class="p">.</span><span class="n">mock_device</span><span class="p">.</span><span class="n">add_test_device</span><span class="p">(</span><span class="n">mock_simple_device</span><span class="p">)</span>
</pre></div>
</div>
<p>Once you have the mock device there are a number of helper methods available on the device that can be used to make
writing tests a little easier.  Most commonly there is <cite>mock_device:generate_test_message(component_id, capability_event)</cite>
to generate a test capability event message coming from the device.  See the test method examples below for usage.</p>
<p>Another use of the mock device is that you can use the <cite>get_field</cite> and <cite>set_field</cite> functions that are present on the
true device object to set or read fields during a test to control the behavior of the driver under test.  Here is a
simple example verifying that a field is set as expected</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="n">test</span><span class="p">.</span><span class="n">register_coroutine_test</span><span class="p">(</span>
    <span class="s2">&quot;On command should set status field to </span><span class="se">\&quot;</span><span class="s2">on</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="kr">function</span><span class="p">()</span>
      <span class="n">test</span><span class="p">.</span><span class="n">socket</span><span class="p">.</span><span class="n">zigbee</span><span class="p">:</span><span class="n">__queue_receive</span><span class="p">({</span><span class="n">mock_device</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">clusters</span><span class="p">.</span><span class="n">OnOff</span><span class="p">.</span><span class="n">attributes</span><span class="p">.</span><span class="n">OnOff</span><span class="p">:</span><span class="n">build_test_attr_report</span><span class="p">(</span><span class="n">mock_device</span><span class="p">,</span> <span class="kc">true</span><span class="p">)})</span>
      <span class="n">test</span><span class="p">.</span><span class="n">wait_for_events</span><span class="p">()</span>
      <span class="nb">assert</span><span class="p">(</span><span class="n">mock_device</span><span class="p">:</span><span class="n">get_field</span><span class="p">(</span><span class="s2">&quot;status&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;on&quot;</span><span class="p">,</span> <span class="s2">&quot;Status should be on after on attribute report&quot;</span><span class="p">)</span>
    <span class="kr">end</span>
<span class="p">)</span>
</pre></div>
</div>
<p>There are also a few different options for using the mock device object to generate either expected output of the driver
or drive input to trigger the driver to act.  First is the <cite>mock_device:expect_metadata_update(metadata)</cite> which can be
used if you are expecting your driver to change some information about the device.  And in the other direction if you
want to simulate some of your devices data being changed by an outside source you can use
<cite>mock_device:generate_info_changed(changed_values)</cite> to build a message that can be queued to be received on the
<cite>device_lifecycle</cite> channel.  Here is a simple snippet using both of these concepts:</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="n">test</span><span class="p">.</span><span class="n">register_coroutine_test</span><span class="p">(</span>
    <span class="s2">&quot;A preference value changed should update the profile&quot;</span><span class="p">,</span>
    <span class="kr">function</span><span class="p">()</span>
      <span class="n">test</span><span class="p">.</span><span class="n">socket</span><span class="p">.</span><span class="n">device_lifecycle</span><span class="p">:</span><span class="n">__queue_receive</span><span class="p">(</span><span class="n">mock_device</span><span class="p">:</span><span class="n">generate_info_changed</span><span class="p">({</span> <span class="n">preferences</span> <span class="p">{</span> <span class="n">myPreference</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">}</span> <span class="p">}))</span>
      <span class="n">mock_device</span><span class="p">:</span><span class="n">expect_metadata_update</span><span class="p">({</span> <span class="n">profile</span> <span class="o">=</span> <span class="s2">&quot;new-profile&quot;</span> <span class="p">})</span>
    <span class="kr">end</span>
<span class="p">)</span>
</pre></div>
</div>
<dl class="lua class">
<dt id="integration_test.MockDevice">
<em class="property">class </em><code class="sig-name descname">integration_test.MockDevice</code><a class="headerlink" href="#integration_test.MockDevice" title="Permalink to this definition">¶</a></dt>
<dd><dl class="lua method">
<dt id="integration_test.MockDevice.generate_test_message">
<em class="property"> </em><code class="sig-name descname">generate_test_message</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">component_id</em>, <em class="sig-param">capability_event</em><span class="sig-paren">)</span><a class="headerlink" href="#integration_test.MockDevice.generate_test_message" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a test message representing this device emitting the given event</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>self</strong> (<a class="reference internal" href="#integration_test.MockDevice" title="integration_test.MockDevice"><em>integration_test.MockDevice</em></a>) – </p></li>
<li><p><strong>component_id</strong> (<em>str</em>) – the component this event should be generated for</p></li>
<li><p><strong>capability_event</strong> (<em>table</em>) – the capability event</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the message objecte needed for a message test or __expect_send on the capability channel</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>table</p>
</dd>
</dl>
</dd></dl>

<dl class="lua staticmethod">
<dt id="integration_test.MockDevice.set_field">
<em class="property">static </em><code class="sig-name descname">set_field</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">key</em>, <em class="sig-param">value</em>, <em class="sig-param">opts</em><span class="sig-paren">)</span><a class="headerlink" href="#integration_test.MockDevice.set_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a device field value if the driver test hasn’t been initialized yet</p>
<p>Because the MockDevice typically is a passthrough into the actual device within the driver under test
typically get_field will refer to the actual device object in the driver under test.  However, because
the MockDevice persists between tests and can be referred to when a test isn’t running and thus the
device passthrough can’t be done, it will maintain it’s own fields store that will be used to populate the
device object when the device does start.  This mock method will only be called when the device passthrough
is not available and will set a field in the mock field store</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>self</strong> (<a class="reference internal" href="#integration_test.MockDevice" title="integration_test.MockDevice"><em>integration_test.MockDevice</em></a>) – </p></li>
<li><p><strong>key</strong> (<em>str</em>) – the key of the field to get</p></li>
<li><p><strong>value</strong> (<em>any</em>) – the value to store to the field</p></li>
<li><p><strong>opts</strong> (<em>table</em>) – additional options (persist bool)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="lua method">
<dt id="integration_test.MockDevice.get_field">
<em class="property"> </em><code class="sig-name descname">get_field</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">key</em><span class="sig-paren">)</span><a class="headerlink" href="#integration_test.MockDevice.get_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a device field value if the driver test hasn’t been initialized yet</p>
<p>Because the MockDevice typically is a passthrough into the actual device within the driver under test
typically get_field will refer to the actual device object in the driver under test.  However, because
the MockDevice persists between tests and can be referred to when a test isn’t running and thus the
device passthrough can’t be done, it will maintain it’s own fields store that will be used to populate the
device object when the device does start.  This mock method will only be called when the device passthrough
is not available and will return from the mock field store.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>self</strong> (<a class="reference internal" href="#integration_test.MockDevice" title="integration_test.MockDevice"><em>integration_test.MockDevice</em></a>) – </p></li>
<li><p><strong>key</strong> (<em>str</em>) – the key of the field to get</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="lua method">
<dt id="integration_test.MockDevice.expect_metadata_update">
<em class="property"> </em><code class="sig-name descname">expect_metadata_update</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">metadata</em><span class="sig-paren">)</span><a class="headerlink" href="#integration_test.MockDevice.expect_metadata_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the test to expect a device metadata update to be generated</p>
<p>This takes args of the same form as st.Device:try_update_metadata</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>self</strong> (<a class="reference internal" href="#integration_test.MockDevice" title="integration_test.MockDevice"><em>integration_test.MockDevice</em></a>) – </p></li>
<li><p><strong>metadata</strong> (<em>table</em>) – the metadata update command that is expected to be sent</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="lua method">
<dt id="integration_test.MockDevice.generate_info_changed">
<em class="property"> </em><code class="sig-name descname">generate_info_changed</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">metadata</em><span class="sig-paren">)</span><a class="headerlink" href="#integration_test.MockDevice.generate_info_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a device_lifecycle infoChanged message to be queued in tests</p>
<p>This takes a table of key,value pairs to update info about this device. These should
only be keys that would be present in the st_store of a device object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>self</strong> (<a class="reference internal" href="#integration_test.MockDevice" title="integration_test.MockDevice"><em>integration_test.MockDevice</em></a>) – </p></li>
<li><p><strong>metadata</strong> (<em>table</em>) – the metadata update command that is expected to be sent</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="lua staticmethod">
<dt id="integration_test.MockDevice.init">
<em class="property">static </em><code class="sig-name descname">init</code><span class="sig-paren">(</span><em class="sig-param">raw_st_data</em>, <em class="sig-param">additional_mock_fields</em><span class="sig-paren">)</span><a class="headerlink" href="#integration_test.MockDevice.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a MockDevice from st_data and additional mock fields</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raw_st_data</strong> (<em>table</em>) – the values representing this device that would be used on the ST platform</p></li>
<li><p><strong>additional_mock_fields</strong> (<em>table</em>) – any additional fields that this device should mock out</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the constructed mock device</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#integration_test.MockDevice" title="integration_test.MockDevice">integration_test.MockDevice</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="environment-preparation">
<h3>Environment Preparation<a class="headerlink" href="#environment-preparation" title="Permalink to this headline">¶</a></h3>
<p>Some protocols depend on certain environment info in order for the driver to execute as expected.  Depending on the test
you are writing it may be necessary to populate this information in the test environment.  The most common case where
this is necessary is having access to the hub’s Zigbee EUI which is necessary for configuring reporting for newly joined
devices.  One option is to use an <cite>environment_info</cite> message to populate this, but if you don’t care about that as a
part of your test, you can make a call to <cite>zigbee_test_utils.prepare_zigbee_env_info()</cite> once within your test file and
this will pre-populate the driver under test with this necessary information before running any of the tests in the file.</p>
</div>
<div class="section" id="test-init">
<span id="id1"></span><h3>test_init<a class="headerlink" href="#test-init" title="Permalink to this headline">¶</a></h3>
<p>If is quite common to want to do some repeated work at the start of every test (e.g. add a test device to your test
driver).  This can be done by setting up a <code class="docutils literal notranslate"><span class="pre">test_init</span></code> funciton.  There are 2 ways you can do this.  The first, and
most common, way you will want to do this is using a shared function within your test file.  This can be done by calling
<code class="docutils literal notranslate"><span class="pre">integration_test.set_test_init_function(your_init_function)</span></code>.  The function you provide here will be called before
every test.  So continuing our earlier example of wanting to add a test device before every test following is how you
would set that up:</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="kd">local</span> <span class="n">test</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">&quot;integration_test&quot;</span>
<span class="kd">local</span> <span class="n">t_utils</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">&quot;integration_test.utils&quot;</span>
<span class="kd">local</span> <span class="n">capabilities</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">&quot;st.capabilities&quot;</span>

<span class="kd">local</span> <span class="n">mock_simple_device</span> <span class="o">=</span> <span class="n">test</span><span class="p">.</span><span class="n">mock_device</span><span class="p">.</span><span class="n">build_test_zigbee_device</span><span class="p">({</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">t_utils</span><span class="p">.</span><span class="n">get_profile_definition</span><span class="p">(</span><span class="s2">&quot;test-profile.yml&quot;</span><span class="p">)</span> <span class="p">})</span>

<span class="kd">local</span> <span class="kr">function</span> <span class="nf">test_init</span><span class="p">()</span>
  <span class="n">test</span><span class="p">.</span><span class="n">mock_device</span><span class="p">.</span><span class="n">add_test_device</span><span class="p">(</span><span class="n">mock_simple_device</span><span class="p">)</span>
<span class="kr">end</span>

<span class="n">test</span><span class="p">.</span><span class="n">set_test_init_function</span><span class="p">(</span><span class="n">test_init</span><span class="p">)</span>
</pre></div>
</div>
<p>And now every test you register will have that device available.</p>
<p>The second way you can provide this initialization is via the <code class="docutils literal notranslate"><span class="pre">opts</span></code> table within the test registration to override
the global init just described, and provide a specific init for just one test.  This will be described in more detail
below in the section on the test <code class="docutils literal notranslate"><span class="pre">opts</span></code>.</p>
</div>
</div>
<div class="section" id="message-driver-tests">
<h2>Message Driver Tests<a class="headerlink" href="#message-driver-tests" title="Permalink to this headline">¶</a></h2>
<p>A message driver test verifies that given a set of inputs (“receive” messages) the driver produces the correct set of
outputs (“send” messages) in the correct order. A very common example of this is the driver receiving a protocol message
(e.g. a Zigbee message from the radio) for a device, and the driver sends out a capability attribute event for the
device. Or conversely, the driver receives a capability command for a device, and the driver sends out a protocol
message.  Following are an example of each for a Zigbee bulb</p>
<p>Zigbee radio message -&gt; capability attribute event</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="kd">local</span> <span class="n">test</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">&quot;integration_test&quot;</span>
<span class="kd">local</span> <span class="n">t_utils</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">&quot;integration_test.utils&quot;</span>
<span class="kd">local</span> <span class="n">clusters</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">&quot;st.zigbee.zcl.clusters&quot;</span>
<span class="kd">local</span> <span class="n">OnOffCluster</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">.</span><span class="n">OnOffCluster</span>
<span class="kd">local</span> <span class="n">capabilities</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">&quot;st.capabilities&quot;</span>
<span class="kd">local</span> <span class="n">zigbee_test_utils</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">&quot;integration_test.zigbee_test_utils&quot;</span>

<span class="kd">local</span> <span class="n">mock_simple_device</span> <span class="o">=</span> <span class="n">test</span><span class="p">.</span><span class="n">mock_device</span><span class="p">.</span><span class="n">build_test_zigbee_device</span><span class="p">({</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">t_utils</span><span class="p">.</span><span class="n">get_profile_definition</span><span class="p">(</span><span class="s2">&quot;test-profile.yml&quot;</span><span class="p">)</span> <span class="p">})</span>
<span class="n">test</span><span class="p">.</span><span class="n">mock_device</span><span class="p">.</span><span class="n">add_test_device</span><span class="p">(</span><span class="n">mock_simple_device</span><span class="p">)</span>

<span class="n">test</span><span class="p">.</span><span class="n">register_message_test</span><span class="p">(</span>
    <span class="s2">&quot;Reported on off status should be handled: on&quot;</span><span class="p">,</span>
    <span class="p">{</span>
      <span class="p">{</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="s2">&quot;zigbee&quot;</span><span class="p">,</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;receive&quot;</span><span class="p">,</span>
        <span class="n">message</span> <span class="o">=</span> <span class="p">{</span> <span class="n">mock_simple_device</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">OnOffCluster</span><span class="p">.</span><span class="n">attributes</span><span class="p">.</span><span class="n">OnOff</span><span class="p">:</span><span class="n">build_test_attr_report</span><span class="p">(</span><span class="n">mock_simple_device</span><span class="p">,</span>
                                                                                                <span class="kc">true</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">},</span>
      <span class="p">{</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="s2">&quot;capability&quot;</span><span class="p">,</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;send&quot;</span><span class="p">,</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">mock_simple_device</span><span class="p">:</span><span class="n">generate_test_message</span><span class="p">(</span><span class="s2">&quot;main&quot;</span><span class="p">,</span> <span class="n">capabilities</span><span class="p">.</span><span class="n">switch</span><span class="p">.</span><span class="n">switch</span><span class="p">.</span><span class="n">on</span><span class="p">())</span>
      <span class="p">}</span>
    <span class="p">}</span>
<span class="p">)</span>

<span class="n">run_registered_tests</span><span class="p">()</span>
</pre></div>
</div>
<p>Capability command -&gt; Zigbee radio message</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="kd">local</span> <span class="n">test</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">&quot;integration_test&quot;</span>
<span class="kd">local</span> <span class="n">t_utils</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">&quot;integration_test.utils&quot;</span>
<span class="kd">local</span> <span class="n">clusters</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">&quot;st.zigbee.zcl.clusters&quot;</span>
<span class="kd">local</span> <span class="n">LevelControlCluster</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">.</span><span class="n">LevelControlCluster</span>
<span class="kd">local</span> <span class="n">capabilities</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">&quot;st.capabilities&quot;</span>
<span class="kd">local</span> <span class="n">zigbee_test_utils</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">&quot;integration_test.zigbee_test_utils&quot;</span>

<span class="kd">local</span> <span class="n">mock_simple_device</span> <span class="o">=</span> <span class="n">test</span><span class="p">.</span><span class="n">mock_device</span><span class="p">.</span><span class="n">build_test_zigbee_device</span><span class="p">({</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">t_utils</span><span class="p">.</span><span class="n">get_profile_definition</span><span class="p">(</span><span class="s2">&quot;test-profile.yml&quot;</span><span class="p">)</span> <span class="p">})</span>
<span class="n">test</span><span class="p">.</span><span class="n">mock_device</span><span class="p">.</span><span class="n">add_test_device</span><span class="p">(</span><span class="n">mock_simple_device</span><span class="p">)</span>

<span class="n">test</span><span class="p">.</span><span class="n">register_message_test</span><span class="p">(</span>
    <span class="s2">&quot;Capability command setLevel should be handled&quot;</span><span class="p">,</span>
    <span class="p">{</span>
      <span class="p">{</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="s2">&quot;capability&quot;</span><span class="p">,</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;receive&quot;</span><span class="p">,</span>
        <span class="n">message</span> <span class="o">=</span> <span class="p">{</span> <span class="n">mock_simple_device</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="p">{</span> <span class="n">capability</span> <span class="o">=</span> <span class="s2">&quot;switchLevel&quot;</span><span class="p">,</span> <span class="n">command</span> <span class="o">=</span> <span class="s2">&quot;setLevel&quot;</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">57</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}</span>
      <span class="p">},</span>
      <span class="p">{</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="s2">&quot;zigbee&quot;</span><span class="p">,</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;send&quot;</span><span class="p">,</span>
        <span class="n">message</span> <span class="o">=</span> <span class="p">{</span> <span class="n">mock_simple_device</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">LevelControlCluster</span><span class="p">.</span><span class="n">commands</span><span class="p">.</span><span class="n">client</span><span class="p">.</span><span class="n">MoveToLevelWithOnOff</span><span class="p">(</span><span class="n">mock_simple_device</span><span class="p">,</span>
                                                                                                    <span class="nb">math.floor</span><span class="p">(</span><span class="mi">57</span> <span class="o">*</span> <span class="mh">0xFE</span> <span class="o">/</span> <span class="mi">100</span><span class="p">),</span>
                                                                                                    <span class="mi">0</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
<span class="p">)</span>

<span class="n">run_registered_tests</span><span class="p">()</span>
</pre></div>
</div>
<div class="section" id="opts">
<h3>opts<a class="headerlink" href="#opts" title="Permalink to this headline">¶</a></h3>
<p>The message test also takes an optional third argument <cite>opts</cite> which can be used to set additional controls for the test.</p>
<div class="section" id="inner-block-ordering">
<h4>inner_block_ordering<a class="headerlink" href="#inner-block-ordering" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">inner_block_ordering</span></code> argument defaults to <cite>“strict”</cite> but can be set to
<cite>“relaxed”</cite>.  To understand this argument, first we can define what a “block” of messages is.  In general the message
tests will be broken into a series of “blocks” each of which is 1 “receive” message (i.e. external stimulus) followed by
any number (0 included) of “send” messages (output).  So the <cite>inner_block_ordering</cite> set to relax specifically means that
within a given block, the “send” messages must all be sent, but can be sent in any order.  This is primarily needed in
tests where a single “receive” message results in many “send” messages, but those “send” messages are created within the
driver by iterating over a table.  Because iterating over a table does not have a guaranteed order, we relax our test
expectations to require all messages be sent, but not the order.  Important to note is that the order of the blocks
themselves will still be strictly in the order they are presented.  Following is an example of a test using this option</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="kd">local</span> <span class="n">test</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">&quot;integration_test&quot;</span>
<span class="kd">local</span> <span class="n">t_utils</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">&quot;integration_test.utils&quot;</span>
<span class="kd">local</span> <span class="n">clusters</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">&quot;st.zigbee.zcl.clusters&quot;</span>
<span class="kd">local</span> <span class="n">LevelControlCluster</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">.</span><span class="n">LevelControlCluster</span>
<span class="kd">local</span> <span class="n">OnOffCluster</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">.</span><span class="n">OnOffCluster</span>
<span class="kd">local</span> <span class="n">capabilities</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">&quot;st.capabilities&quot;</span>
<span class="kd">local</span> <span class="n">zigbee_test_utils</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">&quot;integration_test.zigbee_test_utils&quot;</span>

<span class="kd">local</span> <span class="n">mock_simple_device</span> <span class="o">=</span> <span class="n">test</span><span class="p">.</span><span class="n">mock_device</span><span class="p">.</span><span class="n">build_test_zigbee_device</span><span class="p">({</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">t_utils</span><span class="p">.</span><span class="n">get_profile_definition</span><span class="p">(</span><span class="s2">&quot;test-profile.yml&quot;</span><span class="p">)</span> <span class="p">})</span>
<span class="n">test</span><span class="p">.</span><span class="n">mock_device</span><span class="p">.</span><span class="n">add_test_device</span><span class="p">(</span><span class="n">mock_simple_device</span><span class="p">)</span>

<span class="n">test</span><span class="p">.</span><span class="n">register_message_test</span><span class="p">(</span>
    <span class="s2">&quot;Configuration Capability Command should configure device&quot;</span><span class="p">,</span>
    <span class="p">{</span>
      <span class="p">{</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="s2">&quot;environment_update&quot;</span><span class="p">,</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;receive&quot;</span><span class="p">,</span>
        <span class="n">message</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;zigbee&quot;</span><span class="p">,</span> <span class="p">{</span> <span class="n">hub_zigbee_id</span> <span class="o">=</span> <span class="n">base64</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">zigbee_test_utils</span><span class="p">.</span><span class="n">mock_hub_eui</span><span class="p">)</span> <span class="p">}</span> <span class="p">},</span>
      <span class="p">},</span>
      <span class="p">{</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="s2">&quot;device_lifecycle&quot;</span><span class="p">,</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;receive&quot;</span><span class="p">,</span>
        <span class="n">message</span> <span class="o">=</span> <span class="p">{</span> <span class="n">mock_simple_device</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="s2">&quot;added&quot;</span> <span class="p">},</span>
      <span class="p">},</span>
      <span class="p">{</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="s2">&quot;capability&quot;</span><span class="p">,</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;receive&quot;</span><span class="p">,</span>
        <span class="n">message</span> <span class="o">=</span> <span class="p">{</span>
          <span class="n">mock_simple_device</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
          <span class="p">{</span> <span class="n">capability</span> <span class="o">=</span> <span class="s2">&quot;configuration&quot;</span><span class="p">,</span> <span class="n">command</span> <span class="o">=</span> <span class="s2">&quot;configure&quot;</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="p">{}</span> <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">},</span>
      <span class="p">{</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="s2">&quot;zigbee&quot;</span><span class="p">,</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;send&quot;</span><span class="p">,</span>
        <span class="n">message</span> <span class="o">=</span> <span class="p">{</span>
          <span class="n">mock_simple_device</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
          <span class="n">zigbee_test_utils</span><span class="p">.</span><span class="n">build_bind_request</span><span class="p">(</span><span class="n">mock_simple_device</span><span class="p">,</span>
                                               <span class="n">zigbee_test_utils</span><span class="p">.</span><span class="n">mock_hub_eui</span><span class="p">,</span>
                                               <span class="n">OnOffCluster</span><span class="p">.</span><span class="n">ID</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">},</span>
      <span class="p">{</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="s2">&quot;zigbee&quot;</span><span class="p">,</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;send&quot;</span><span class="p">,</span>
        <span class="n">message</span> <span class="o">=</span> <span class="p">{</span>
          <span class="n">mock_simple_device</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
          <span class="n">OnOffCluster</span><span class="p">.</span><span class="n">attributes</span><span class="p">.</span><span class="n">OnOff</span><span class="p">:</span><span class="n">configure_reporting</span><span class="p">(</span><span class="n">mock_simple_device</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">},</span>
      <span class="p">{</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="s2">&quot;zigbee&quot;</span><span class="p">,</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;send&quot;</span><span class="p">,</span>
        <span class="n">message</span> <span class="o">=</span> <span class="p">{</span>
          <span class="n">mock_simple_device</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
          <span class="n">zigbee_test_utils</span><span class="p">.</span><span class="n">build_bind_request</span><span class="p">(</span><span class="n">mock_simple_device</span><span class="p">,</span>
                                               <span class="n">zigbee_test_utils</span><span class="p">.</span><span class="n">mock_hub_eui</span><span class="p">,</span>
                                               <span class="n">LevelControlCluster</span><span class="p">.</span><span class="n">ID</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">},</span>
      <span class="p">{</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="s2">&quot;zigbee&quot;</span><span class="p">,</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;send&quot;</span><span class="p">,</span>
        <span class="n">message</span> <span class="o">=</span> <span class="p">{</span>
          <span class="n">mock_simple_device</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
          <span class="n">LevelControlCluster</span><span class="p">.</span><span class="n">attributes</span><span class="p">.</span><span class="n">CurrentLevel</span><span class="p">:</span><span class="n">configure_reporting</span><span class="p">(</span><span class="n">mock_simple_device</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3600</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">},</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="n">inner_block_ordering</span> <span class="o">=</span> <span class="s2">&quot;relaxed&quot;</span>
    <span class="p">}</span>
<span class="p">)</span>

<span class="n">run_registered_tests</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>test_init<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Additionally, you can set the field <code class="docutils literal notranslate"><span class="pre">test_init</span></code> in the opts to a function.  This function will replace the global
<a class="reference internal" href="#id4"><span class="std std-ref">test init</span></a> function for just this test.  This would allow you to set up a different device for an
individual test, or otherwise manage test specific setup.</p>
</div>
</div>
</div>
<div class="section" id="coroutine-tests">
<h2>Coroutine Tests<a class="headerlink" href="#coroutine-tests" title="Permalink to this headline">¶</a></h2>
<p>If you prefer the syntax of writing a function as a test, or you need to interact with datastores or timers, you can
use a “coroutine” test.  All “message” tests can be described as a coroutine test, but you have some additional control
in this test format.  This will still work largely in the format of, set up input (often a “receive” message, but could
also be a timer expiring), expect output, then return control to the driver.  The primary way to set up input would be
queueing a message to be received on a certain “channel” that your driver is subscribed to.  The syntax for this is:</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="n">integration_test</span><span class="p">.</span><span class="n">socket</span><span class="p">.</span><span class="o">&lt;</span><span class="n">socket_name</span><span class="o">&gt;</span><span class="p">:</span><span class="n">__queue_receive</span><span class="p">(</span><span class="o">&lt;</span><span class="n">socket_specific_message</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>or for a concrete example:</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="n">test</span><span class="p">.</span><span class="n">socket</span><span class="p">.</span><span class="n">zigbee</span><span class="p">:</span><span class="n">__queue_receive</span><span class="p">(</span>
  <span class="p">{</span>
    <span class="n">mock_device</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
    <span class="n">OccupancySensingCluster</span><span class="p">.</span><span class="n">attributes</span><span class="p">.</span><span class="n">Occupancy</span><span class="p">:</span><span class="n">build_test_attr_report</span><span class="p">(</span>
        <span class="n">mock_device</span><span class="p">,</span>
        <span class="mh">0x01</span>
    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>And similarly you can set up the expected output from your driver:</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="n">integration_test</span><span class="p">.</span><span class="n">socket</span><span class="p">.</span><span class="o">&lt;</span><span class="n">socket_name</span><span class="o">&gt;</span><span class="p">:</span><span class="n">__expect_send</span><span class="p">(</span><span class="o">&lt;</span><span class="n">socket_specific_message</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="n">test</span><span class="p">.</span><span class="n">socket</span><span class="p">.</span><span class="n">zigbee</span><span class="p">:</span><span class="n">__expect_send</span><span class="p">(</span>
  <span class="p">{</span>
    <span class="n">mock_simple_device</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
    <span class="n">OnOffCluster</span><span class="p">.</span><span class="n">attributes</span><span class="p">.</span><span class="n">OnOff</span><span class="p">:</span><span class="n">read</span><span class="p">(</span><span class="n">mock_simple_device</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Putting these together into a simple test:</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="n">integration_test</span><span class="p">.</span><span class="n">register_coroutine_test</span><span class="p">(</span>
    <span class="s2">&quot;my test&quot;</span><span class="p">,</span>
    <span class="kr">function</span><span class="p">()</span>
      <span class="n">integration_test</span><span class="p">.</span><span class="n">socket</span><span class="p">.</span><span class="n">zigbee</span><span class="p">:</span><span class="n">__queue_receive</span><span class="p">(</span>
        <span class="p">{</span>
          <span class="n">mock_simple_device</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
          <span class="n">OnOffCluster</span><span class="p">.</span><span class="n">attributes</span><span class="p">.</span><span class="n">OnOff</span><span class="p">:</span><span class="n">build_test_attr_report</span><span class="p">(</span>
              <span class="n">mock_simple_device</span><span class="p">,</span>
              <span class="kc">true</span>
          <span class="p">)</span>
        <span class="p">}</span>
      <span class="n">integration_test</span><span class="p">.</span><span class="n">socket</span><span class="p">.</span><span class="n">capability</span><span class="p">:</span><span class="n">__expect_send</span><span class="p">(</span>
          <span class="n">mock_simple_device</span><span class="p">:</span><span class="n">generate_test_message</span><span class="p">(</span><span class="s2">&quot;main&quot;</span><span class="p">,</span> <span class="n">capabilities</span><span class="p">.</span><span class="n">switch</span><span class="p">.</span><span class="n">switch</span><span class="p">.</span><span class="n">on</span><span class="p">())</span>
      <span class="p">)</span>

      <span class="n">integration_test</span><span class="p">.</span><span class="n">wait_for_events</span><span class="p">()</span>

      <span class="n">integration_test</span><span class="p">.</span><span class="n">socket</span><span class="p">.</span><span class="n">capability</span><span class="p">:</span><span class="n">__queue_receive</span><span class="p">(</span>
          <span class="p">{</span>
            <span class="n">mock_device</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
            <span class="p">{</span> <span class="n">capability</span> <span class="o">=</span> <span class="s2">&quot;switch&quot;</span><span class="p">,</span> <span class="n">command</span> <span class="o">=</span> <span class="s2">&quot;on&quot;</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="p">{}</span> <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">)</span>
      <span class="n">integration_test</span><span class="p">.</span><span class="n">socket</span><span class="p">.</span><span class="n">zigbee</span><span class="p">:</span><span class="n">__expect_send</span><span class="p">(</span>
        <span class="p">{</span>
          <span class="n">mock_simple_device</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
          <span class="n">OnOffCluster</span><span class="p">.</span><span class="n">commands</span><span class="p">.</span><span class="n">client</span><span class="p">.</span><span class="n">On</span><span class="p">(</span><span class="n">mock_simple_device</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">)</span>
    <span class="kr">end</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This is a simple test that will verify first that given a Zigbee “On” report, a capability event for <cite>switch.switch = on</cite>
is generated, then, will verify that a capability command of <cite>switch.switch.on</cite> will result in the expected Zigbee
command. This example could be expressed as a “message” test, but shows the equivalent in a “coroutine” test.</p>
<div class="section" id="id3">
<h3>opts<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>The coroutine test also takes an optional third argument <cite>opts</cite> which can be used to set additional controls for the
test.</p>
<div class="section" id="id4">
<h4>test_init<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>You can set the field <code class="docutils literal notranslate"><span class="pre">test_init</span></code> in the opts to a function.  This function will replace the global
<a class="reference internal" href="#id4"><span class="std std-ref">test init</span></a> function for just this test.  This would allow you to set up a different device for an
individual test, or otherwise manage test specific setup.</p>
<div class="section" id="zigbee-add-hub-to-zigbee-group">
<h5>Zigbee <cite>add_hub_to_zigbee_group</cite><a class="headerlink" href="#zigbee-add-hub-to-zigbee-group" title="Permalink to this headline">¶</a></h5>
<p>For drivers that have the permission to allow them to add the SmartThings hub to a specific Zigbee group, you may also
want the ability to test that this works as expected.  This is done by an additional expect function available on the
<cite>zigbee</cite> test socket.  Specifically you can use <cite>__expect_add_hub_to_group(group_id)</cite> to queue the expect before
you would expect your driver under test to send the command.</p>
<p>This test will verify that upon receipt of the binding table read response the hub will be added to a group based off
a value in that response.  This would be device specific behavior, but the method for testing the call to add the hub to
a group is generic.</p>
</div>
<div class="section" id="test-completion">
<h5>Test Completion<a class="headerlink" href="#test-completion" title="Permalink to this headline">¶</a></h5>
<p>Because the standard libraries default implementation will set up some periodic timers for drivers, and because drivers
are “long running” (i.e. they behave as if the code is always running), we need to know when a test is done so that we
can stop the driver under test from running forever and move on to the next test.  This is determined by having “no more
work” to do.  Practically what this means is if the driver under test checks to see if it has any more input to process
(typically either a received/input message to process or an expired timer, or the test function coroutine has not
completed), and there is none, the test will be considered complete and we will verify that all expectations were
fulfilled and return control to the test code to run the next test.</p>
</div>
<div class="section" id="timers">
<h5>Timers<a class="headerlink" href="#timers" title="Permalink to this headline">¶</a></h5>
<p>Timers are a common use case for driver execution.  Whether they be timer that gets set up automatically on startup
to run every X seconds, or upon receiving some input you want to delay 2 seconds before doing the next action, we
need a way to handle these within driver tests.  Because there may be timers created automatically by the standard
libraries, but we don’t want those to interfere with tests, the default behavior for a driver creating a timer (either
<cite>call_on_schedule</cite> or <cite>call_with_delay</cite>) from the test environment is to return a timer that will never fire.  In
addition, because of the way timer handling works, if you want behavior other than the above, you must define the timer
before the driver requests it so that it can be returned to the driver as the correct “timer” object.</p>
<p>The timer object can be completely customized if it is necessary, however, in most cases using the helper functions to
create some standard template timers.  The most common of these will be the “time advance timer” which is a mock timer
that will automatically “fire” after mock time is advanced by a certain amount. Following is a trivial example:</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="n">test</span><span class="p">.</span><span class="n">register_coroutine_test</span><span class="p">(</span>
    <span class="s2">&quot;timer test&quot;</span><span class="p">,</span>
    <span class="kr">function</span><span class="p">()</span>
      <span class="c1">-- create a mock timer that will automatically fire after mock time moves forward 100 seconds</span>
      <span class="n">test</span><span class="p">.</span><span class="n">timer</span><span class="p">.</span><span class="n">__create_and_queue_test_time_advance_timer</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="s2">&quot;oneshot&quot;</span><span class="p">)</span>

      <span class="c1">-- Add whatever queue&#39;d input will result in a call to `call_with_delay` which will be returned the</span>
      <span class="c1">-- above timer</span>

      <span class="c1">-- let the driver run</span>
      <span class="n">test</span><span class="p">.</span><span class="n">wait_for_events</span><span class="p">()</span>

      <span class="c1">-- Advance mock time by 100 seconds</span>
      <span class="n">test</span><span class="p">.</span><span class="n">mock_time</span><span class="p">.</span><span class="n">advance_time</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>

      <span class="c1">-- Add whatever expects for the results of the timer firing here</span>
    <span class="kr">end</span>
<span class="p">)</span>
</pre></div>
</div>
<p>In this case we create a “oneshot” timer (used with call_with_delay) that will be returned the next time the driver
requests a timer of that type.  Once that timer is created and prepped, the test should set up the driver to be in the
necessary state to request that timer.  The test yields to let the driver run and request the test.  Then because the
timer we created was a time advance timer, it will automatically “fire” from the drivers perspective once test time is
advanced by 100 seconds, so we make the call to advance time, and then we would set up whatever expectations we have
of the driver given that the timer will fire.</p>
<p>Here is a real example of a timer test:</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="n">test</span><span class="p">.</span><span class="n">register_coroutine_test</span><span class="p">(</span>
    <span class="s2">&quot;set color command test&quot;</span><span class="p">,</span>
    <span class="kr">function</span><span class="p">()</span>
      <span class="n">test</span><span class="p">.</span><span class="n">timer</span><span class="p">.</span><span class="n">__create_and_queue_test_time_advance_timer</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;oneshot&quot;</span><span class="p">)</span>
      <span class="n">test</span><span class="p">.</span><span class="n">socket</span><span class="p">.</span><span class="n">capability</span><span class="p">:</span><span class="n">__queue_receive</span><span class="p">({</span>
          <span class="n">mock_device</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
          <span class="p">{</span> <span class="n">capability</span> <span class="o">=</span> <span class="s2">&quot;colorControl&quot;</span><span class="p">,</span> <span class="n">command</span> <span class="o">=</span> <span class="s2">&quot;setColor&quot;</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="n">hue</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="n">saturation</span> <span class="o">=</span> <span class="mi">50</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}</span> <span class="p">})</span>
      <span class="p">}</span>
      <span class="n">test</span><span class="p">.</span><span class="n">socket</span><span class="p">.</span><span class="n">zigbee</span><span class="p">:</span><span class="n">__expect_send</span><span class="p">(</span>
          <span class="p">{</span>
            <span class="n">mock_device</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
            <span class="n">OnOffCluster</span><span class="p">.</span><span class="n">commands</span><span class="p">.</span><span class="n">client</span><span class="p">.</span><span class="n">On</span><span class="p">(</span><span class="n">mock_device</span><span class="p">)</span>
          <span class="p">}</span>
      <span class="p">)</span>
      <span class="kd">local</span> <span class="n">hue</span> <span class="o">=</span> <span class="nb">math.floor</span><span class="p">((</span><span class="mi">50</span> <span class="o">*</span> <span class="mh">0xFE</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.0</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
      <span class="kd">local</span> <span class="n">sat</span> <span class="o">=</span> <span class="nb">math.floor</span><span class="p">((</span><span class="mi">50</span> <span class="o">*</span> <span class="mh">0xFE</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.0</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
      <span class="n">test</span><span class="p">.</span><span class="n">socket</span><span class="p">.</span><span class="n">zigbee</span><span class="p">:</span><span class="n">__expect_send</span><span class="p">(</span>
          <span class="p">{</span>
            <span class="n">mock_device</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
            <span class="n">ColorControlCluster</span><span class="p">.</span><span class="n">commands</span><span class="p">.</span><span class="n">client</span><span class="p">.</span><span class="n">MoveToHueAndSaturation</span><span class="p">(</span>
                <span class="n">mock_device</span><span class="p">,</span>
                <span class="n">hue</span><span class="p">,</span>
                <span class="n">sat</span><span class="p">,</span>
                <span class="mh">0x0000</span>
            <span class="p">)</span>
          <span class="p">}</span>
      <span class="p">)</span>

      <span class="n">test</span><span class="p">.</span><span class="n">wait_for_events</span><span class="p">()</span>

      <span class="n">test</span><span class="p">.</span><span class="n">mock_time</span><span class="p">.</span><span class="n">advance_time</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
      <span class="n">test</span><span class="p">.</span><span class="n">socket</span><span class="p">.</span><span class="n">zigbee</span><span class="p">:</span><span class="n">__expect_send</span><span class="p">(</span>
          <span class="p">{</span>
              <span class="n">mock_device</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
              <span class="n">ColorControlCluster</span><span class="p">.</span><span class="n">attributes</span><span class="p">.</span><span class="n">ColorControlCurrentHue</span><span class="p">:</span><span class="n">read</span><span class="p">(</span><span class="n">mock_device</span><span class="p">)</span>
          <span class="p">}</span>
      <span class="p">)</span>
      <span class="n">test</span><span class="p">.</span><span class="n">socket</span><span class="p">.</span><span class="n">zigbee</span><span class="p">:</span><span class="n">__expect_send</span><span class="p">(</span>
          <span class="p">{</span>
              <span class="n">mock_device</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
              <span class="n">ColorControlCluster</span><span class="p">.</span><span class="n">attributes</span><span class="p">.</span><span class="n">ColorControlCurrentSaturation</span><span class="p">:</span><span class="n">read</span><span class="p">(</span><span class="n">mock_device</span><span class="p">)</span>
          <span class="p">}</span>
      <span class="p">)</span>
    <span class="kr">end</span>
<span class="p">)</span>
</pre></div>
</div>
<p>In this example we test receiving a <cite>colorControl.setColor</cite> command from the cloud for a Zigbee bulb.  In this case we
will immediately send an on command and a command to move the bulb to the correct hue and saturation, however, we also
want to send a read to get the updated device values.  But because the bulb will go through a transition phase, that
read is delayed by 2 seconds.</p>
<p>If a more generic timer is needed the function
<cite>timer_api.__create_and_queue_generic_timer = function(ready_check_func, timer_class)</cite> is available. Here you simply
provide a function that will be called repeatedly to determine if a timer is ready to fire and should return true/false.
Important to note that this check may be called multiple times before the timer itself is actually handled, and as such
it is recommended that your check function use the <cite>self.__handled</cite> value which will not be true until the timer has
actually been returned to the driver to be handled.
`</p>
</div>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="datastore.html" class="btn btn-neutral float-right" title="Datastore" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="dispatchers.html" class="btn btn-neutral" title="Dispatchers" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, SmartThings Developers.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> and ❤️  using a custom <a href="https://github.com/LinxiFan/Sphinx-theme">theme</a> based on <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/language_data.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>